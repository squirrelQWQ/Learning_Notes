### 环境

##### 环境变量名称

%%可以调来用windows系统的其它环境变量，比如：%JAVA_HOME%，使你定义的变量更直观

JAVA_HOME是一个约定，通常它指的是JDK的目录。如果需要JDK的话，大部分程序会默认去环境变量中取JAVA_HOME这个变量。

##### 环境变量顺序

系统在执行用户命令时，若用户未给出绝对路径，则首先在当前目录下寻找相应的可执行文件、批处理文件等。若找不到，再依次在PATH保存的这些路径中寻找相应的可执行程序文件（windows环境变量的查找顺序是按照文件的录入顺序从前往后寻找的，最前面一条的优先级最高，如果找到命令就不会再向后找了）。

##### 两个程序

javac.exe：其中 c 指 compile ，顾名思义，javac.exe 就是编译源文件，生成 .class 文件

java.exe ：运行 .class 文件的程序



比较清楚的介绍环境变量：https://blog.csdn.net/weixin_33382711/article/details/114703742



### 变量

java中的变量可以理解为是一个“指针变量”，故变量之间赋值就是使两个指针指向同一块内存空间：

```java
Music m1 = new Music();//表示新建m1变量且为其分配了一块内存放置Music类数据
Music m2;//表示只新建了m2变量，但并未分配内存放置Music类数据
```



**局部变量：**方法中定义的变量

**成员变量：**（类似于c中全局变量）定义在方法体和语句块之外，是以下变量统称

- 类变量（静态变量）：属于类本身，独立于方法之外，需要**static**修饰
- 实例变量（非静态变量）：独立于方法之外的变量，依赖实例存在，不需要static修饰
- 常量：final修饰，全大写字母，中间用下划线连接

### 访问修饰符

#### 基本介绍

- public：
  - public类源码必须在其同名的.java文件中
  - 共有，对所有类可见
- private：私有，在同一类内可见（同一个类的两个对象都可见）
- frindly：默认选项，不指明的话就是该修饰符，同一个包内可见
  - 接口中的变量默认为：public static final
  - 接口中的方法默认为：public
- protected：类A用它修饰，表示只有同一个包内的类和所有子类可见

#### 与继承相关

- 父类中声明为public的方法在子类中也必须为public。

- 父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。
- 父类中默认修饰符声明的方法，能够在子类中声明为private。
- 父类中声明为private的方法，不能够被继承。

- 





### **关键字**

- static：
  - 用它修饰的变量叫类变量（是属于类的而非对象的变量），修改该变量值所有该类或对象调用该变量，其值都会改变
  - 用它修饰的函数叫类函数（是属于类的而非对象的函数），其不能调用非静态方法，对于静态方法没有this
  - 简单的来说static作用就是可以不创建对象就调用类的方法和对象
  
- abstract

  - 抽象类不能生成对象（含有抽象函数的都是抽象类）
  - 它可以使其所有子类都具有它的抽象函数（但函数的具体实现由子类自己完成，即子类必须覆盖父类的抽象函数）

  **This：**
  
  - 用于区分类的成员变量和局部变量（解决变量重名问题）
  - this.a    表示调用成员变量a
  
  

### 继承

**新建一个对象时初始化的顺序**：

1. 执行父类成员变量定义初始化代码
2. 执行父类的构造器（默认使用不带参数的构造器，也可以使用super来选择构造器）
3. 执行子类成员变量定义初始化代码
4. 执行子类的构造器（若子类和父类有同名同类的成员变量，则子类构造器中初始化的变量是子类的成员变量（就近原则））

**子类的对象可以被当作父类的对象来使用，如以下场景**

1. 赋值给父类的变量
2. 传递给需要父类对象的函数
3. 放进存放父类对象的容器里

java的所有变量都是多态变量，即可以是代码字面上的（静态变量）也可以是改变量的子类变量（动态变量）

**造型（cast）**

个人理解：比如：List list = new ArrayList<>();

向上造型：即拿一个子类的对象，当作父类的对象

- 向上造型是默认的，不需要运算符
- 向上造型总是安全的



### 面向对象

#### 接口

- 接口中所有方法都是abstract方法（不指名就默认如此）
- 接口中所有变量都是abstract final变量
- 接口类不能产生对象，必须由新的类来完成接口中方法的定义（implements）

#### 构造器

父类若只定义有参构造器，则子类定义无参构造器时会报错，故定义了有参构造器后一定要同时写上无参构造器

- 什么都不写，默认有一个无参构造器
- 写了有参构造器但不写无参构造器，则没有无参构造器







### **异常：**

- 捕捉到异常后，发生异常那行代码之后的代码不会执行了

- 好处：将业务逻辑代码与遇到情况时的处理代码分开，使代码更清晰可读性，可扩展性增强
- 抛出子类异常会被捕捉父类异常的catch给抓住
- 异常的爹是Exception，所以catch可以用它来兜底

若调用一个声明会抛出异常的函数（Public void f() throws Exception{}），必须：

1. 把函数的调用放在try块中，并设置catch来捕捉可能会抛出的异常
2. 声明自己会抛出无法处理的异常

当覆盖一个函数的时候子类不能声明比父类的版本更多的异常

在子类的构造函数中，必须声明父类可能抛出的全部异常

**流：**

- 是一维（用一个数字能定位）单方向（）的
- 流过滤器
- 文本处理：Writer，Reader
- 对象串行化

**内部类**

- 成员内部类，静态内部类，局部内部类，匿名内部类

- https://www.cnblogs.com/ldl326308/p/9477566.html





### 名词解释

#### 项目结构

> 工程（project）、模块（module）、包（package）

**project**：包含项目的所有代码，包括前端、后端源码以及各种库文件

**module**：从项目整体功能角度分割代码，从而分别进行独立开发

**package**：这玩意儿就很重要的，注意点很多

- 作用一：隔离java文件
- 作用二：控制访问范围
- 作用三：防止类名冲突，所有类都一定属于某个包
  - 我们常说的类名其实只是一个简写，比如：User
  - 完整的类名是（<font color='red'>全限定类名</font>）：包名.类名
- 命名习惯：包的命名一般是域名的返写，比如：com.spring.learning



#### 访问权限

|                                              | 同一个类 | 同一个包 | 不同包的子类 | 不同包的非子类 |
| -------------------------------------------- | -------- | -------- | ------------ | -------------- |
| public                                       | OK       | OK       | OK           | OK             |
| protected                                    | OK       | OK       | OK           |                |
| friendly（<font color='red'>default</font>） | OK       | OK       |              |                |
| private                                      | OK       |          |              |                |



private：私有，在同一类内可见（同一个类的两个对象都可见）







