线程三种创建方式：

- 继承Thread类，重写run方法
- 实现Runnable接口，实现run方法（推荐使用，避免单继承局限性，灵活方便，方便同一个对象被多个线程使用）
- 实现Callable接口，重写call方法，需要抛出异常（目前只做了解）

（各线程微观串行，宏观并行）线程创建后不一定立即执行，执行时间由CPU调度

静态代理：

动态代理：

Lamda表达式：

- 函数式接口：只有一个抽象方法的接口就叫函数式接口，要使用这种接口对象时可以提供一个lambda表达式（使用lambda的前提）
- 函数体只有一句时才能使lambda表达式变成一行
- 多个参数也可以去掉参数类型，但必须都去掉且必须加上括号“()”

补充：runnable就是一个函数式接口

**线程五态：**

- 和进程一样：创建，就绪，阻塞，运行，结束

- 推荐的停止线程的方法：设置一个标志位flag，当flag = false终止线程运行

  **Thread：**

  - 线程停止：推荐设置一个flag，通过调用方法改变flag值从而结束线程，不推荐使用stop方法

  - 线程睡眠sleep：每个线程都有一把锁，sleep不会释放锁

  - 线程礼让Yield：使线程放弃cpu使用权进入就绪态，与其它线程再次竞争cpu
  - 线程join：让线程插队，直到它结束才释放cpu
  - 观察状态：Thread.state()
  - 优先级：getPriority()，setPriority()，优先级越高越容易获得资源（实际谁先跑由JVM决定）

  **守护线程：**线程分为用户线程和守护线程，JVM必须确保用户线程执行完毕，Thread.setDaemon(true)  设置为守护线程

  

  **线程同步synchronized：**

  - 并发：多个线程访问同一个对象
  - 队列和锁(本质就是互斥锁，写代码时锁那个临界资源即可)
  - 同步块：synchronized(obj){}   其中obj称为同步监视器

  **锁的内存语义：**

  - 锁释放：JVM把对应线程的本地内存中的共享变量写入主存
  - 锁获取：JVM把对应线程本地内存置为无效，使被监视器保护的临界区代码必须从主存中读取共享变量

  **锁释放和锁获取的内存语义：**

  - 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。
  - 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。
  - 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息

**线程协作：**

- 所有对象都有锁，wait()使对象等待，且会释放锁（sleep不释放锁）
- 生产者消费者模型
  - 管程法（设置一个中间缓冲区）
  - 标志法


**线程池：**

- 提前创建好多个线程，放入线程池，使用时直接获取，避免频繁创建和销毁，提高性能，降低资源消耗





 









































































